-- 01 Updating a table with a trigger
-- database: scratch


/*
A trigger is an operation that's automatically performed 
when a specific database event occurs. 

A common use for triggers is to force a table to be updated, 
whenever a row's inserted or updated in another table. 

How triggers are implemented and used vary significantly from system to system 
and MySQL is no exception. 

The syntax used here will work with MySQL 
and will need to be modified if you want to use these techniques in another database management system.
*/

-- create tables 
-- widgetCustomer table
-- last_order_id is updated as result of the trigger
CREATE TABLE widgetCustomer ( id SERIAL, name VARCHAR(255), last_order_id BIGINT );

-- widgetSale table
-- customer_id link to widgetCustomer table
CREATE TABLE widgetSale ( id SERIAL, item_id BIGINT, customer_id BIGINT, quan INT, price DECIMAL(9,2) );

-- update names
INSERT INTO widgetCustomer (name) VALUES ('Bob');
INSERT INTO widgetCustomer (name) VALUES ('Sally');
INSERT INTO widgetCustomer (name) VALUES ('Fred');

-- show widgetCustomer table
SELECT * FROM widgetCustomer;

-- id name last_order_id
-- 1  Bob   NULL
-- 2  Sally NULL
-- 3  Fred  NULL 


/*
CREATE TRIGGER syntax for MySQL - normal SQL 
"FOR EACH ROW" is a MySQL specific thing. 

starts with CREATE TRIGGER and the name of the trigger
 	then the event that the trigger is going to be triggered by
		I.e. INSERT ON widget Sale. 

So when a row's inserted into the widget sale table, after that row is inserted, the trigger is run 

in this case, FOR EACH ROW as just required by MySQL, 
	doesn't actually seem to do anything 
	and then the statement itself that is triggered is this update statement.

So we update the widget customer table 
	and we set the last order ID to the ID from the row that was just inserted into the widget sale 
	and that row that was just inserted is provided to the trigger with this NEW keyword. 

So that's a pseudo table with the, just this one row. It's really just a row and it just points to that row that was just inserted into the table and so that's really convenient. 

I can take the idea of that row, which was automatically generated by this 

"id SERIAL" and can assign that to last_order_id 
	SET last_order_id = NEW.id

and can use it to find the customer_ID
	WHERE id = NEW.customer_id


NEW.customer_id. is the customer ID that we're going to update with the last_order_id. 
	use this WHERE clause in our update and that makes that work. 
		 WHERE id = NEW.customer_id
*/

CREATE TRIGGER newWidgetSale AFTER INSERT ON widgetSale
    FOR EACH ROW
    UPDATE widgetCustomer SET last_order_id = NEW.id WHERE id = NEW.customer_id
;

-- Run the trigger by 
-- inserting 3 rows into this sale table 
--	that will trigger this new widget sale trigger 3 times 
INSERT INTO widgetSale (item_id, customer_id, quan, price) VALUES (1, 3, 5, 19.95);
INSERT INTO widgetSale (item_id, customer_id, quan, price) VALUES (2, 2, 3, 14.95);
INSERT INTO widgetSale (item_id, customer_id, quan, price) VALUES (3, 1, 1, 29.95);

-- take a look at both of these tables
SELECT * FROM widgetSale;


-- id item_id customer_id quan price
-- 1. 1       3           5.   19.95
-- 2. 2.      2           3    14.95
-- 3. 3.      1           1    29.95


-- after trigger, last order id is updated from NULL
SELECT * FROM widgetCustomer;
-- id name last_order_id
-- 1  Bob   3
-- 2  Sally 2
-- 3  Fred  1 


/*
So a trigger is an excellent way to enforce business rules 
	that require a table to be updated whenever another table is updated. 

This example - how to 
	update one table, 
	when a row is inserted into another table. 
*/




-- 02 Preventing automatic updates with a trigger
-- database: scratch

/*
Triggers may also be used to 
	prevent changes to rows that have already been reconciled 
	or should not be changed for other reasons.
*/


DROP TABLE IF EXISTS widgetSale;

// add "reconciled" flag to table structure
CREATE TABLE widgetSale ( id SERIAL, item_id BIGINT, customer_id BIGINT, quan INT, price DECIMAL(9,2), reconciled INT );

/*
inserting some rows into the table, 
	item number 2 and I'm setting that flag "On" that 1 
	Others "Off" or 0 
*/

INSERT INTO widgetSale (item_id, customer_id, quan, price, reconciled) VALUES (1, 3, 5, 19.95, 0);
INSERT INTO widgetSale (item_id, customer_id, quan, price, reconciled) VALUES (2, 2, 3, 14.95, 1);
INSERT INTO widgetSale (item_id, customer_id, quan, price, reconciled) VALUES (3, 1, 1, 29.95, 0);
SELECT * FROM widgetSale;


/*
delimiter statement. 
	NOT actually an SQL statement. 
	MySQL uses in their command line client 
	a common paradigm in my SQL.
	it allows you to use semicolons within a statement 
		without actually terminating the statement.

The CREATE TRIGGER actually has two statements in it 
	the If that requires a semicolon. 
	the SIGNAL statement that also requires a semicolon because it's a separate statement. 

in order for this all to be treated as one unit, changed the delimeter 
	from semicolon ;
	to   double slash // 
 
that's a common paradigm in MySQL 

then set the Delimiter back to the semicolon afterwards 
	to use it in the rest of this code.

what this trigger does, 

BEFORE UPDATE ON widget sale, 
	so when you go to update an already existing row in the widget sale table. 
	Before the update is applied, this triggered code will be executed.

And what this triggered code does, you'll notice we have 
	the FOR EACH row which is required for CREATE TRIGGER. 
	BEGIN END block - that allows more than one statement to be part of this trigger. 	    the IF statement 
			checks the reconciled flag in this row that's about to be updated. 	this NEW.id 
		we have the row that's about to be updated, 
			and it's all ready to be updated in to the table, 
			but has Not been committed yet to the database. 
	
	check and see for that row whether the reconciled flag is greater than zero. 
		IF ( SELECT reconciled FROM widgetSale WHERE id = NEW.id ) > 0 	

	if it is, set/throw an error. This SIGNAL statement allows you to throw an error in MySQL; only for MySQL version 5.5+  
	SQLSTATE '45000' is a generic unhandled exception, which means that its an error that will end a transaction.
	SET MESSAGE_TEXT to the error msg

		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Error: cannot update reconciled row in widgetSale';

Set the delimiter back
*/

DELIMITER //
CREATE TRIGGER updateWidgetSale BEFORE UPDATE ON widgetSale
    FOR EACH ROW
    BEGIN
        IF ( SELECT reconciled FROM widgetSale WHERE id = NEW.id ) > 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Error: cannot update reconciled row in widgetSale';
        END IF;
    END
//
DELIMITER ;

/*
and we start a transaction 
	actually prevent this table from getting updated 
	when updated within a transaction, 

we throw an error that will end the transaction before the data is committed.
*/


-- did Not allow adding 9 to the quantity
-- reconciled flag is 1; On; Don't allow update
-- error shown
--  "query #9 SQLSTATE[45000]:<>: 1644 Error: 
--	cannot update reconciled row in widgetSale"
START TRANSACTION;
UPDATE widgetSale SET quan = quan + 9 WHERE id = 2;
COMMIT;

SELECT * FROM widgetSale;


-- quan id same before and after update is The Same
-- id item_id customer_id quan price reconciled
-- 1.  1.     3.           5.  19.95. 0
-- 2.  2.     2.           3.  14.95  1
-- 3.  3.     1.           1.  29.95. 0


-- Will be updated
-- reconciled flag is 0; Off; allow update
START TRANSACTION;
UPDATE widgetSale SET quan = quan + 9 WHERE id = 1;
COMMIT;


-- quan updates from 5 to 14 
-- id item_id customer_id quan price reconciled
-- 1.  1.     3.           5.  19.95. 0
-- 2.  2.     2.           3.  14.95  1
-- 3.  3.     1.           1.  29.95. 0

-- id item_id customer_id quan price reconciled
-- 1.  1.     3.           14.  19.95. 0
-- 2.  2.     2.           3.  14.95  1
-- 3.  3.     1.           1.  29.95. 0





-- Alternate error code for MySQL versions prior to 5.5
--  it fakes the error by trying to update a table that doesn't exist. 
-- And this table doesn't exist is the error message.
-- 	query #9: SQLSTATE[42502]: Base table or view not found: 1146 Table
--	 'scratch.Error: cannot update reconciled row in widgetSale' doesn't exist

IF ( SELECT reconciled FROM widgetSale WHERE id = NEW.id ) > 0 THEN
    UPDATE `Error: cannot update reconciled row in widgetSale` SET x=1;
END IF;


DELIMITER //
CREATE TRIGGER updateWidgetSale BEFORE UPDATE ON widgetSale
    FOR EACH ROW
    BEGIN 
	-- MySQL pre-5.5 versions
	IF ( SELECT reconciled FROM widgetSale WHERE id = NEW.id ) > 0 THEN
    		UPDATE `Error: cannot update reconciled row in widgetSale` SET x=1;
	END IF;
    END
//
DELIMITER ;

/*
triggers may be used to prevent changes to tables or rows that should not be changed.
	It's a simple usage and it's a valuable business tool. Keep in mind that triggers, errors and signals are all implemented differently from system to system. This code will work. With MySQL, but you'll need to change it in order for it to work with other systems. 
*/




-- 03 Logging transactions with a trigger
-- 	use a trigger to update a transaction log.
-- database: xxx

-- recreate the sale table 
-- to get rid of that reconciled flag t
DROP TABLE IF EXISTS widgetSale;

CREATE TABLE widgetSale ( id SERIAL, item_id BIGINT, customer_id BIGINT, quan INT, price DECIMAL(9,2) );

// log table has SERIAL, TIMESTAMP
CREATE TABLE widgetLog ( id SERIAL, stamp TIMESTAMP, event VARCHAR(255), username VARCHAR(255),
    tablename VARCHAR(255), table_id BIGINT);



/*
 using the delimiter, to change the delimiter because we have multiple statements here in our trigger. So this allows all of this to be submitted to the database engine as one unit.

a very MySQL specific paradigm. The trigger itself is an after insert trigger, so when you insert a row in widget sale, this trigger will be triggered and this code will be executed. And you notice we insert three rows here into the sale table. So between begin and end we have a block of code with two statements in it. 

	The first one, sets the last order ID in customer like we did in the first example 	    UPDATE widgetCustomer SET last_order_id = NEW.id
	            WHERE widgetCustomer.id = NEW.customer_id;

	the second one, inserts into the widget log to log the event.
	widget sale will get that new id from the sale row that's being inserted into the sale table. 
		INSERT INTO widgetLog (event, username, tablename, table_id)
            		VALUES ('INSERT', 'TRIGGER', 'widgetSale', NEW.id);	

*/
DELIMITER //
CREATE TRIGGER stampSale AFTER INSERT ON widgetSale
    FOR EACH ROW
    BEGIN
        UPDATE widgetCustomer SET last_order_id = NEW.id
            WHERE widgetCustomer.id = NEW.customer_id;
        INSERT INTO widgetLog (event, username, tablename, table_id)
            VALUES ('INSERT', 'TRIGGER', 'widgetSale', NEW.id);
    END
//
DELIMITER ;

INSERT INTO widgetSale (item_id, customer_id, quan, price) VALUES (1, 3, 5, 19.95);
INSERT INTO widgetSale (item_id, customer_id, quan, price) VALUES (2, 2, 3, 14.95);
INSERT INTO widgetSale (item_id, customer_id, quan, price) VALUES (3, 1, 1, 29.95);

SELECT * FROM widgetSale;
SELECT * FROM widgetCustomer;
SELECT * FROM widgetLog;



-- Sales table
-- id item_id customer_id quan price
-- 1. 1        3.          5.  19.95
-- 2. 2.       2.          3.  14.95
-- 3. 3.       1           1   29.95

-- Customer - updated with sales
-- Id name last_order_id
-- 1  Bob     3
-- 2  Sally   2
-- 3. Fred.   1


-- log table
-- link back to the sale table
-- id stamp 			event 	username 	table_id
-- 1 2014-03-28 06:02:00	INSERT	TRIGGER		1
-- 2 2014-03-28 06:02:00	INSERT	TRIGGER		2
-- 3 2014-03-28 06:02:00	INSERT	TRIGGER		3

/*
So very simple technique. For updating a log whenever a row is inserted into a table. You can use triggers for many purposes. Here, I've shown you how to update two tables from one trigger including a new row and a transaction log table. And, updating this customer table with the last order ID.
*/


-- restore database
-- every time you drop a table, 
--	the triggers associated with that table are automatically dropped. 
-- note: in other systems where they don't automatically drop a trigger, 
-- 		get an error if you drop a table Before you drop the associated trigger, 
-- so always drop the triggers 1st, before dropping the associated tables.

DROP TRIGGER IF EXISTS newWidgetSale;
DROP TRIGGER IF EXISTS updateWidgetSale;
DROP TRIGGER IF EXISTS widgetLog;

DROP TABLE IF EXISTS widgetCustomer;
DROP TABLE IF EXISTS widgetSale;
DROP TABLE IF EXISTS widgetLog;

